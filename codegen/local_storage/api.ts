/* tslint:disable */
/* eslint-disable */
/**
 * CasaOS Local Storage API
 * <picture>     <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://raw.githubusercontent.com/IceWhaleTech/logo/main/casaos/casaos_banner_dark_night_800px.png\">     <source media=\"(prefers-color-scheme: light)\" srcset=\"https://raw.githubusercontent.com/IceWhaleTech/logo/main/casaos/casaos_banner_twilight_blue_800px.png\">     <img alt=\"CasaOS\" src=\"https://raw.githubusercontent.com/IceWhaleTech/logo/main/casaos/casaos_banner_twilight_blue_800px.png\"> </picture>  CasaOS Local Storage service manages local storage including disks, partitions and mounting points.  This API allows interacting with the service to conduct such management.  For issues and discussions, please visit the [GitHub repository](https://github.com/IceWhaleTech/CasaOS) or join [our Discord](https://discord.gg/knqAbbBbeX).
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof BaseResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetMerges200Response
 */
export interface GetMerges200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetMerges200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Merge>}
     * @memberof GetMerges200Response
     */
    'data'?: Array<Merge>;
}
/**
 * 
 * @export
 * @interface GetMerges200ResponseAllOf
 */
export interface GetMerges200ResponseAllOf {
    /**
     * 
     * @type {Array<Merge>}
     * @memberof GetMerges200ResponseAllOf
     */
    'data'?: Array<Merge>;
}
/**
 * 
 * @export
 * @interface GetMounts200Response
 */
export interface GetMounts200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetMounts200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Mount>}
     * @memberof GetMounts200Response
     */
    'data'?: Array<Mount>;
}
/**
 * 
 * @export
 * @interface GetMounts200ResponseAllOf
 */
export interface GetMounts200ResponseAllOf {
    /**
     * 
     * @type {Array<Mount>}
     * @memberof GetMounts200ResponseAllOf
     */
    'data'?: Array<Mount>;
}
/**
 * 
 * @export
 * @interface Merge
 */
export interface Merge {
    /**
     * 
     * @type {number}
     * @memberof Merge
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'fstype'?: string;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'mount_point': string;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'source_base_path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Merge
     */
    'source_volume_paths'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface Mount
 */
export interface Mount {
    /**
     * 
     * @type {number}
     * @memberof Mount
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'mount_point': string;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'fstype'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'options'?: string;
    /**
     * Extended properties of the mount
     * @type {{ [key: string]: string; }}
     * @memberof Mount
     */
    'extended'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SetMerge200Response
 */
export interface SetMerge200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof SetMerge200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Merge}
     * @memberof SetMerge200Response
     */
    'data'?: Merge;
}
/**
 * 
 * @export
 * @interface SetMerge200ResponseAllOf
 */
export interface SetMerge200ResponseAllOf {
    /**
     * 
     * @type {Merge}
     * @memberof SetMerge200ResponseAllOf
     */
    'data'?: Merge;
}
/**
 * 
 * @export
 * @interface UpdateMount200Response
 */
export interface UpdateMount200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof UpdateMount200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Mount}
     * @memberof UpdateMount200Response
     */
    'data'?: Mount;
}
/**
 * 
 * @export
 * @interface UpdateMount200ResponseAllOf
 */
export interface UpdateMount200ResponseAllOf {
    /**
     * 
     * @type {Mount}
     * @memberof UpdateMount200ResponseAllOf
     */
    'data'?: Mount;
}
/**
 * 
 * @export
 * @interface Volume
 */
export interface Volume {
    /**
     * 
     * @type {number}
     * @memberof Volume
     */
    'id'?: number;
    /**
     * (TODO)
     * @type {string}
     * @memberof Volume
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'path': string;
    /**
     * (TODO)
     * @type {number}
     * @memberof Volume
     */
    'state'?: number;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'mount_point': string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'created_at'?: string;
}

/**
 * MergeMethodsApi - axios parameter creator
 * @export
 */
export const MergeMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (TODO)
         * @summary Get merges
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerges: async (mountPoint?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Set a merge
         * @param {Merge} merge 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMerge: async (merge: Merge, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merge' is not null or undefined
            assertParamExists('setMerge', 'merge', merge)
            const localVarPath = `/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(merge, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MergeMethodsApi - functional programming interface
 * @export
 */
export const MergeMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MergeMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * (TODO)
         * @summary Get merges
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerges(mountPoint?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMerges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerges(mountPoint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (TODO)
         * @summary Set a merge
         * @param {Merge} merge 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMerge(merge: Merge, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetMerge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMerge(merge, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MergeMethodsApi - factory interface
 * @export
 */
export const MergeMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MergeMethodsApiFp(configuration)
    return {
        /**
         * (TODO)
         * @summary Get merges
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerges(mountPoint?: string, options?: any): AxiosPromise<GetMerges200Response> {
            return localVarFp.getMerges(mountPoint, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Set a merge
         * @param {Merge} merge 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMerge(merge: Merge, options?: any): AxiosPromise<SetMerge200Response> {
            return localVarFp.setMerge(merge, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MergeMethodsApi - object-oriented interface
 * @export
 * @class MergeMethodsApi
 * @extends {BaseAPI}
 */
export class MergeMethodsApi extends BaseAPI {
    /**
     * (TODO)
     * @summary Get merges
     * @param {string} [mountPoint] Filter the results by mount point
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MergeMethodsApi
     */
    public getMerges(mountPoint?: string, options?: AxiosRequestConfig) {
        return MergeMethodsApiFp(this.configuration).getMerges(mountPoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Set a merge
     * @param {Merge} merge 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MergeMethodsApi
     */
    public setMerge(merge: Merge, options?: AxiosRequestConfig) {
        return MergeMethodsApiFp(this.configuration).setMerge(merge, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MountMethodsApi - axios parameter creator
 * @export
 */
export const MountMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
         * @summary Get mounted volumes
         * @param {string} [id] Filter the results by id
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {string} [type] Filter the results by type
         * @param {string} [source] Filter the results by source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMounts: async (id?: string, mountPoint?: string, type?: string, source?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Mount a volume
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mount: async (mount: Mount, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mount' is not null or undefined
            assertParamExists('mount', 'mount', mount)
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Umount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umount: async (mountPoint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mountPoint' is not null or undefined
            assertParamExists('umount', 'mountPoint', mountPoint)
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
         * @summary Update a mount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMount: async (mountPoint: string, mount: Mount, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mountPoint' is not null or undefined
            assertParamExists('updateMount', 'mountPoint', mountPoint)
            // verify required parameter 'mount' is not null or undefined
            assertParamExists('updateMount', 'mount', mount)
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MountMethodsApi - functional programming interface
 * @export
 */
export const MountMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MountMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
         * @summary Get mounted volumes
         * @param {string} [id] Filter the results by id
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {string} [type] Filter the results by type
         * @param {string} [source] Filter the results by source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMounts(id?: string, mountPoint?: string, type?: string, source?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMounts(id, mountPoint, type, source, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (TODO)
         * @summary Mount a volume
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mount(mount: Mount, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mount(mount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (TODO)
         * @summary Umount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umount(mountPoint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umount(mountPoint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
         * @summary Update a mount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMount(mountPoint: string, mount: Mount, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMount(mountPoint, mount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MountMethodsApi - factory interface
 * @export
 */
export const MountMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MountMethodsApiFp(configuration)
    return {
        /**
         * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
         * @summary Get mounted volumes
         * @param {string} [id] Filter the results by id
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {string} [type] Filter the results by type
         * @param {string} [source] Filter the results by source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMounts(id?: string, mountPoint?: string, type?: string, source?: string, options?: any): AxiosPromise<GetMounts200Response> {
            return localVarFp.getMounts(id, mountPoint, type, source, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Mount a volume
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mount(mount: Mount, options?: any): AxiosPromise<UpdateMount200Response> {
            return localVarFp.mount(mount, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Umount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umount(mountPoint: string, options?: any): AxiosPromise<BaseResponse> {
            return localVarFp.umount(mountPoint, options).then((request) => request(axios, basePath));
        },
        /**
         * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
         * @summary Update a mount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMount(mountPoint: string, mount: Mount, options?: any): AxiosPromise<UpdateMount200Response> {
            return localVarFp.updateMount(mountPoint, mount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MountMethodsApi - object-oriented interface
 * @export
 * @class MountMethodsApi
 * @extends {BaseAPI}
 */
export class MountMethodsApi extends BaseAPI {
    /**
     * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
     * @summary Get mounted volumes
     * @param {string} [id] Filter the results by id
     * @param {string} [mountPoint] Filter the results by mount point
     * @param {string} [type] Filter the results by type
     * @param {string} [source] Filter the results by source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public getMounts(id?: string, mountPoint?: string, type?: string, source?: string, options?: AxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).getMounts(id, mountPoint, type, source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Mount a volume
     * @param {Mount} mount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public mount(mount: Mount, options?: AxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).mount(mount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Umount volume
     * @param {string} mountPoint Filter the results by mount point
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public umount(mountPoint: string, options?: AxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).umount(mountPoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
     * @summary Update a mount volume
     * @param {string} mountPoint Filter the results by mount point
     * @param {Mount} mount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public updateMount(mountPoint: string, mount: Mount, options?: AxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).updateMount(mountPoint, mount, options).then((request) => request(this.axios, this.basePath));
    }
}


